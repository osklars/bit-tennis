=== Scala ===

--- server/src/main/scala/StateService.scala ---

import cats.effect.{IO, Ref}
import cats.syntax.all.*
import fs2.Stream
import fs2.concurrent.Topic
import model.InvalidEvent
import model.api.in.{Event, NewMatch}
import model.api.out.StateSummary
import model.pingis.MatchState

class StateService
(
  state: Ref[IO, MatchState],
  updates: Topic[IO, StateSummary]
):
  def newMatch(input: NewMatch): IO[StateSummary] =
    val newState = MatchState(input)
    for
      _ <- state.set(newState)
      summary = StateSummary(newState)
      _ <- updates.publish1(summary)
    yield summary

  def process(event: Event): IO[StateSummary] =
    for
      current <- state.get
      _ <- IO.println("handling event", current, event)
      newState <- current.process(event)
        .liftTo[IO](InvalidEvent(event, StateSummary(current)))
      _ <- IO.println("got new state", newState)
      _ <- state.set(newState)
      summary = StateSummary(event, newState)
      _ <- updates.publish1(summary)
    yield summary

  def getState: IO[StateSummary] = state.get.map(StateSummary.apply)

  def subscribe: Stream[IO, StateSummary] =
    updates
      .subscribeUnbounded
--- server/src/main/scala/model/types/EventType.scala ---

package model.types

import upickle.default.*

enum EventType derives ReadWriter:
  case Throw, ExitTable, Net // only relevant for serves
  case Racket, Board, Out

--- server/src/main/scala/model/types/RallyState.scala ---

package model.types

import upickle.default.*

enum RallyState derives ReadWriter:
  case Idle, ToServe, ToBounce1, ToBounce2, NetServe // Serve states
  case ToStrike, ToBounce // Return states

--- server/src/main/scala/model/types/Points.scala ---

package model.types

import upickle.default.*

case class Points(A: Int, B: Int) derives ReadWriter:
  def inc(player: Player): Points = player match {
    case Player.A => copy(A + 1)
    case Player.B => copy(B = B + 1)
  }

--- server/src/main/scala/model/types/Player.scala ---

package model.types

import upickle.default.*

enum Player derives ReadWriter:
  case A, B

  lazy val opponent: Player = this match
    case Player.A => Player.B
    case Player.B => Player.A
--- server/src/main/scala/model/pingis/SetState.scala ---

package model.pingis

import model.api.in.Event
import model.types.{Player, Points, RallyState}
import upickle.default.*

case object SetState:
  def apply(firstServer: Player): SetState =
    SetState(
      GameState(firstServer),
      firstServer = firstServer,
    )

case class SetState
(
  game: GameState,
  points: Points = Points(0, 0),
  firstServer: Player,
):
  def process(event: Event): Option[SetState] = game.process(event).map {
    case GameState(_, _, p, _) if p.A >= 11 && p.A >= p.B + 2 => awardPoint(Player.A)
    case GameState(_, _, p, _) if p.B >= 11 && p.B >= p.A + 2 => awardPoint(Player.B)
    case g => copy(game = g)
  }

  private def awardPoint(player: Player): SetState = {
    val newFirstServer = firstServer.opponent
    SetState(
      game = GameState(RallyState.Idle, newFirstServer, Points(0, 0), firstServer),
      points = points.inc(player),
      firstServer = newFirstServer,
    )
  }
  

--- server/src/main/scala/model/pingis/GameState.scala ---

package model.pingis

import model.api.in.Event
import model.types.EventType.*
import model.types.RallyState.*
import model.types.{EventType, Player, Points, RallyState}

case object GameState:
  def apply(firstServer: Player): GameState =
    GameState(
      possession = firstServer,
      firstServer = firstServer,
    )

case class GameState
(
  rallyState: RallyState = Idle,
  possession: Player = Player.A, // a player has possession of the ball until it's the other players turn to hit it
  points: Points = Points(0, 0),
  firstServer: Player = Player.A,
):
  def process(event: Event): Option[GameState] =
    Option(rallyState, event).collect {
      // serving
      case (Idle, Event(Throw, Some(this.possession))) => copy(ToServe)

      case (ToServe, Event(Racket, Some(this.possession))) => copy(ToBounce1)
      case (ToServe, _) => copy(Idle) // ignore events until rally starts with a proper serve

      case (ToBounce1, Event(Board, Some(this.possession))) => copy(ToBounce2)
      case (ToBounce1, _) => awardPoint(possession.opponent)

      case (ToBounce2, Event(Board, Some(possession.opponent))) => copy(ToStrike, possession.opponent)
      case (ToBounce2, Event(Racket, Some(possession.opponent))) => awardPoint(possession)
      case (ToBounce2, Event(Net, _)) => copy(NetServe)
      case (ToBounce2, _) => awardPoint(possession.opponent)

      case (NetServe, Event(Board, Some(possession.opponent))) => copy(Idle)
      case (NetServe, Event(Net, _)) => this
      case (NetServe, _) => awardPoint(possession.opponent)

      // returning
      case (ToStrike, Event(Racket, Some(this.possession))) => copy(ToBounce, possession)
      case (ToStrike, _) => awardPoint(possession.opponent)

      case (ToBounce, Event(Board, Some(possession.opponent))) => copy(ToStrike, possession.opponent)
      case (ToBounce, Event(Racket, Some(possession.opponent))) => awardPoint(possession)
      case (ToBounce, Event(Net, _)) => this
      case (ToBounce, _) => awardPoint(possession.opponent)
    }

  private def awardPoint(player: Player): GameState = {
    val newPoints = points.inc(player)
    copy(
      rallyState = Idle,
      possession = if ((newPoints.A + newPoints.B) % 4 < 2) firstServer else firstServer.opponent,
      points = newPoints,
    )
  }
--- server/src/main/scala/model/pingis/MatchState.scala ---

package model.pingis

import model.api.in.{Event, NewMatch}
import model.types.Player
import upickle.default.*

object MatchState:
  def apply(input: NewMatch): MatchState =
    MatchState(input.playerA, input.playerB, input.bestOf, SetState(input.firstServer))

case class MatchState
(
  playerA: String = "Player A",
  playerB: String = "Player B",
  bestOf: Int = 3,
  set: SetState = SetState(Player.A),
):
  def process(event: Event): Option[MatchState] = 
    set.process(event)
      .map(newSet => copy(set = newSet))

--- server/src/main/scala/model/api/out/ErrorResponse.scala ---

package model.api.out

import upickle.default.*

case class ErrorResponse(error: String) derives ReadWriter

--- server/src/main/scala/model/api/out/StateSummary.scala ---

package model.api.out

import model.api.in.{Event, NewMatch}
import model.pingis.MatchState
import model.types.{Player, Points, RallyState}
import upickle.default.*

case class StateSummary
(
  latestEvent: Option[Event],
  rallyState: RallyState,
  possession: Player,
  gamePoints: Points,
  setPoints: Points
) derives ReadWriter

object StateSummary:

  def apply(event: Event, matchState: MatchState): StateSummary =
    StateSummary(
      latestEvent = Some(event),
      rallyState = matchState.set.game.rallyState,
      possession = matchState.set.game.possession,
      gamePoints = matchState.set.game.points,
      setPoints = matchState.set.points,
    )
  
  def apply(matchState: MatchState): StateSummary =
    StateSummary(
      latestEvent = None,
      rallyState = matchState.set.game.rallyState,
      possession = matchState.set.game.possession,
      gamePoints = matchState.set.game.points,
      setPoints = matchState.set.points,
    )

--- server/src/main/scala/model/api/in/Event.scala ---

package model.api.in

import model.types.{EventType, Player}
import upickle.default.*

case class Event
(
  event: EventType,
  player: Option[Player],
) derives ReadWriter

--- server/src/main/scala/model/api/in/NewMatch.scala ---

package model.api.in

import model.types.Player
import upickle.default.*

case class NewMatch
(
  playerA: String,
  playerB: String,
  bestOf: Int,
  firstServer: Player,
) derives ReadWriter

--- server/src/main/scala/model/InvalidEvent.scala ---

package model

import model.api.in.Event
import model.api.out.StateSummary
import upickle.default.*

case class InvalidEvent(event: Event, state: StateSummary) 
  extends Exception(s"Unhandled event: ${write(event)} with state ${write(state)}") 
    derives ReadWriter
--- server/src/main/scala/Codecs.scala ---

import cats.effect.Concurrent
import upickle.default.*

object Codecs:

  import org.http4s.*

  implicit def upickleEncoder[F[_], A: Writer]: EntityEncoder[F, A] =
    EntityEncoder.stringEncoder[F].contramap[A](write[A](_))

  implicit def upickleDecoder[F[_] : Concurrent, A: Reader]: EntityDecoder[F, A] =
    EntityDecoder.text[F].map(read[A](_))
--- server/src/main/scala/Main.scala ---

import cats.effect.{ExitCode, IO, IOApp, Ref}
import com.comcast.ip4s.*
import fs2.concurrent.Topic
import model.api.out.StateSummary
import model.pingis.MatchState
import org.http4s.*
import org.http4s.ember.server.EmberServerBuilder

import scala.concurrent.duration.DurationInt

object Main extends IOApp:
  def server: IO[ExitCode] =
    for
      state <- Ref.of[IO, MatchState](MatchState())
      updates <- Topic[IO, StateSummary]
      _ <- EmberServerBuilder
        .default[IO]
        .withPort(port"8080")
        .withHost(host"0.0.0.0")
        .withHttpApp(Routes(StateService(state, updates)).corsRoutes.orNotFound)
        .build
        .use(_ => IO.never)
        .handleErrorWith { error =>
          IO.println(s"Server crashed with error: ${error.getMessage}") *>
            IO.sleep(5.seconds) *>
            server // Recursive call to restart
        }
    yield ExitCode.Success

  def run(args: List[String]): IO[ExitCode] = server
--- server/src/main/scala/Routes.scala ---

import cats.effect.IO
import model.InvalidEvent
import model.api.in.{Event, NewMatch}
import org.http4s.dsl.Http4sDsl
import org.http4s.headers.`Content-Type`
import org.http4s.server.middleware.{CORS, ErrorHandling}
import org.http4s.{EntityEncoder, Header, HttpRoutes, MediaType, Response}
import org.typelevel.ci.CIStringSyntax
import upickle.default.*

class Routes(service: StateService) extends Http4sDsl[IO]:

  import Codecs.*

  private val routes: HttpRoutes[IO] = HttpRoutes.of[IO] {
    case req@POST -> Root / "new" =>
      for
        input <- req.as[NewMatch]
        _ <- IO.println(s"Starting new match: $input")
        state <- service.newMatch(input)
        resp <- Ok(state)
      yield resp

    case req@POST -> Root / "event" =>
      for
        event <- req.as[Event]
        result <- service.process(event)
          .map(Right.apply)
          .recover {
            case i: InvalidEvent =>
              println(i)
              Left(i)
          }
        resp <- result match
          case Left(value) => Accepted(value)
          case Right(value) => Ok(value)
      yield resp

    case GET -> Root / "state" =>
      val stream =
        (fs2.Stream.eval(service.getState) ++ service.subscribe)
          .evalMap(history => IO.println(s"streaming: $history \n${write(history)}").map(_ => history))
          .map(history => s"data: ${write(history)}\n\n")
          .through(fs2.text.utf8.encode)

      Ok(stream).map(_.withHeaders(
        `Content-Type`(MediaType.`text/event-stream`),
        Header.Raw(ci"Cache-Control", "no-cache"),
        Header.Raw(ci"Connection", "keep-alive")
      ))
  }

  val corsRoutes: HttpRoutes[IO] = CORS.policy
    .withAllowOriginAll(ErrorHandling.httpRoutes(routes))

=== Frontend ===

--- frontend/src/app/components/State.tsx ---

'use client';

import {useEffect, useState} from 'react';
import {StateSummary} from '@/lib/types';

export default function State() {
    const [history, setHistory] = useState<StateSummary[]>([]);

    useEffect(() => {
        const eventSource = new EventSource('http://localhost:8080/state');
        eventSource.onmessage = (event) => {
            const data = JSON.parse(event.data);
            console.log("oskar updating history", data);
            setHistory(old => [data, ...old].slice(0, 5));
        };

        return () => eventSource.close();
    }, []);

    return (
        <div className="p-8">
            <h1 className="text-2xl font-bold mb-4">Game State</h1>
            <div className="bg-white rounded-lg shadow p-4">
                <h2 className="font-bold mb-2">Latest Events</h2>
                <div className="space-y-2">
                    {history.map((h, i) => (
                        <div key={i} className="flex items-center space-x-2 text-sm">
                            <span>{h.latestEvent?.event} {h.latestEvent?.player}</span>
                            <span>{h.rallyState} {h.possession} {h.gamePoints.A}:{h.gamePoints.B}</span>
                        </div>
                    ))}
                </div>
            </div>
        </div>
    );
}
--- frontend/src/app/components/Simulator.tsx ---

'use client';

import {EventType, StateSummary, Player, ErrorResponse} from "@/lib/types";
import {useState} from "react";

export default function Simulator() {
    const [state, setState] = useState<StateSummary | ErrorResponse>();

    const sendEvent = async (event: EventType, player?: Player) => {
        const body = JSON.stringify({
            event,
            player: player || null
        })
        try {
            console.log("oskar posting event", body);
            const response = await fetch('http://localhost:8080/event', {
                method: 'POST',
                body,
            });
            const newState = await response.json();
            console.log("oskar posted event", newState);
            setState(newState);
        } catch (e) {
            console.log("oskar post event", e)
        }
    };
    
    return (
        <div className="relative p-16"> {/* Added padding for out area */}
            {/* Out area */}
            <div
                onClick={() => sendEvent(EventType.Out)}
                className="absolute inset-0 bg-gray-100 bg-opacity-50 hover:bg-opacity-70 cursor-pointer"
            />

            {/* Main content - added z-10 to stay above out area */}
            <div className="relative z-10 flex items-center justify-center gap-8">
                <div className="flex items-center justify-center gap-8">
                    {/* Left side */}
                    <div className="flex items-center gap-4">
                        <span className="text-2xl font-bold">A</span>
                        <div className="flex flex-col gap-2">
                            <button
                                onClick={() => sendEvent(EventType.Throw, Player.A)}
                                className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600"
                            >
                                Throw
                            </button>
                            <button
                                onClick={() => sendEvent(EventType.Racket, Player.A)}
                                className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600"
                            >
                                Racket
                            </button>
                        </div>
                    </div>

                    {/* Table */}
                    <div className="border-2 border-gray-400 rounded">
                        <div className="flex">
                            <button
                                onClick={() => sendEvent(EventType.Board, Player.A)}
                                className="w-48 h-32 bg-green-100 hover:bg-green-200 border-r-4 border-gray-400"
                            >
                                Side A
                            </button>
                            <div
                                onClick={() => sendEvent(EventType.Net)}
                                className="w-4 h-32 bg-gray-300 hover:bg-gray-400 cursor-pointer"
                            />
                            <button
                                onClick={() => sendEvent(EventType.Board, Player.B)}
                                className="w-48 h-32 bg-green-100 hover:bg-green-200 border-l-4 border-gray-400"
                            >
                                Side B
                            </button>
                        </div>
                    </div>

                    {/* Right side */}
                    <div className="flex items-center gap-4">
                        <div className="flex flex-col gap-2">
                            <button
                                onClick={() => sendEvent(EventType.Throw, Player.B)}
                                className="px-4 py-2 bg-red-500 text-white rounded hover:bg-red-600"
                            >
                                Throw
                            </button>
                            <button
                                onClick={() => sendEvent(EventType.Racket, Player.B)}
                                className="px-4 py-2 bg-red-500 text-white rounded hover:bg-red-600"
                            >
                                Racket
                            </button>
                        </div>
                        <span className="text-2xl font-bold">B</span>
                    </div>
                </div>
            </div>
        </div>
    
    );
}

// export default function Simulator() {
//
//     const newMatch = async (input: NewMatch) => {
//         console.log("oskar post new", input);
//         try {
//             const response = await fetch('http://localhost:8080/new', {
//                 method: 'POST',
//                 body: JSON.stringify(input),
//             })
//         } catch (e) {
//             console.log("oskar post new", e)
//         }
//     };
//
//     return (
//         <div className="p-8">
//             <h1 className="text-2xl font-bold mb-4">Vision Event Simulator</h1>
//             <div className="grid grid-cols-2 gap-4">
//                 <div>
//                     <h2 className="font-bold mb-2">Player A</h2>
//                     <button
//                         onClick={() => sendEvent(EventType.Racket, Player.A)}
//                         className="w-full mb-2 bg-blue-500 text-white px-4 py-2 rounded"
//                     >
//                         Racket A
//                     </button>
//                     <button
//                         onClick={() => sendEvent(EventType.Board, Player.A)}
//                         className="w-full mb-2 bg-blue-500 text-white px-4 py-2 rounded"
//                     >
//                         Board A
//                     </button>
//                 </div>
//                 <div>
//                     <button
//                         onClick={() => sendEvent(EventType.Net)}
//                         className="w-full mb-2 bg-blue-500 text-white px-4 py-2 rounded"
//                     >
//                         Net
//                     </button>
//                     <button
//                         onClick={() => sendEvent(EventType.Out)}
//                         className="w-full mb-2 bg-blue-500 text-white px-4 py-2 rounded"
//                     >
//                         Out
//                     </button>
//                 </div>
//                 <div>
//                     <h2 className="font-bold mb-2">Player B</h2>
//                     <button
//                         onClick={() => sendEvent(EventType.Racket, Player.B)}
//                         className="w-full mb-2 bg-blue-500 text-white px-4 py-2 rounded"
//                     >
//                         Racket B
//                     </button>
//                     <button
//                         onClick={() => sendEvent(EventType.Board, Player.B)}
//                         className="w-full mb-2 bg-blue-500 text-white px-4 py-2 rounded"
//                     >
//                         Board B
//                     </button>
//                 </div>
//
//                 <div><h2 className="font-bold mb-2">Response: {JSON.stringify(state)}</h2></div>
//             </div>
//         </div>
//     );
// }
--- frontend/src/app/layout.tsx ---

import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        {children}
      </body>
    </html>
  );
}

--- frontend/src/app/page.tsx ---

import State from "@/app/components/State";
import Simulator from "@/app/components/Simulator";

export default function Home() {
    return (
        <div className="p-8">
            <h1 className="text-2xl font-bold mb-4">Table Tennis Tracker</h1>
            <div className="space-y-4">
                <State />
                <Simulator />
            </div>
        </div>
    )
}
--- frontend/src/lib/types.ts ---

// Events
export enum EventType {
    Throw = 'Throw', ExitTable = 'ExitTable', Net = 'Net', // serves
    Racket = 'Racket', Board = 'Board', Out = 'Out',
}

export enum Player {
    A = 'A',
    B = 'B',
}

export type Event = {
    event: EventType,
    player?: Player,
};

export type NewMatch = {
    playerA: string,
    playerB: string,
    bestOf: number,
    firstServer: Player,
}


// State: Latest ball event gives name
export enum RallyState {
    // Serve states
    Idle = 'Idle',
    ToServe = 'ToServe',
    ServeRacket = 'ToBounce1',
    ServeOwnBoard = 'ToBounce2',
    ServeNet = 'NetServe',
    // Return states
    ToStrike = 'ToStrike',
    Board = 'ToBounce',
}

export type Points = {
    A: number,
    B: number,
}

export type StateSummary = {
    latestEvent?: Event,
    rallyState: RallyState,
    possession: Player,
    gamePoints: Points,
    setPoints: Points,
}

export type ErrorResponse = {
    error: string,
}